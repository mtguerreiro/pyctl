import numpy as np

import pyctl

import sys
import ctypes

import os
from shutil import copytree, ignore_patterns

from dataclasses import dataclass

@dataclass
class CodeGenData:

    Am : np.ndarray
    Bm : np.ndarray
    Cm : np.ndarray

    n_pred : int
    n_ctl : int
    n_cnt : int

    Phi : np.ndarray
    RS_bar : np.ndarray
    F : np.ndarray
    

    
def hild_matrices(self, ref='constant'):

    if self.Bm.ndim == 1:
        m = 1
    else:
        m = self.Bm.shape[1]
    
    if ref == 'constant':
        Fj1 = -self.Phi.T @ self.Rs_bar
    else:
        Fj1 = -self.Phi.T
    Fj2 = self.Phi.T @ self.F

    Kj1 = self.M @ self.Ej_inv

    if self.x_lim is None:
        Fx = np.zeros((1,1))
    else:
        Fx = self.Mx_aux @ self.Fx

    Hj = np.zeros(self.Hj.shape, dtype=self.Hj.dtype)
    Hj[:] = self.Hj[:]
    Hj[np.eye(Hj.shape[0],dtype=bool)] = -1 / Hj[np.eye(Hj.shape[0],dtype=bool)]

    #Hj_fxp = (Hj * (2 ** qbase)).astype(np.int64)
    
    DU1 = (-self.Ej_inv)[:m, :]
    DU2 = (-self.Ej_inv @ self.M.T)[:m, :]

    return (Fj1, Fj2, Fx, Kj1, Hj, DU1, DU2)
    
class c_gen:

    def __init__(self):
        pass
    
    def _export_np_array_to_c(self, arr, arr_name, fill=True):

        if arr.ndim == 1:
            n = arr.shape[0]
            m = 1
        else:
            if (arr.shape[0] == 1) or (arr.shape[1] == 1):
                arr = arr.flatten()
                n = arr.shape[0]
                m = 1
            else:
                n, m = arr.shape

        arr_str = np.array2string(arr, separator=',')
        arr_str = arr_str.replace('[', '{')
        arr_str = arr_str.replace(']', '}')

        if m == 1:
            arr_txt = '{:}[{:}];'.format(arr_name, n)
        else:
            arr_txt = '{:}[{:}][{:}];'.format(arr_name, n, m)

        if fill is True:
            arr_txt = arr_txt[:-1] + ' = {:};'.format(arr_str)
            
        return arr_txt
    

    def header(self, ftype='src', prefix=None):

        header = '/**\n'\
         ' * @file {:}\n'\
         ' * @brief Header with data to run the DMPC algorithm.\n'\
         ' *\n'\
         ' * This file is generated automatically and should not be modified.\n'\
         ' *\n'\
         ' * The Hj matrix is already generated by flipping the sign and inverting its\n'\
         ' * diagonal elements, so that Hildreth\'s algorithm does not require any \n'\
         ' * divisions.\n'\
         ' *\n'\
         ' */\n'

        if prefix is None:
            prefix = ''
        else:
            prefix = prefix + '_'
        
        if ftype == 'src':
            file = 'dmpc_matrices.c'
        else:
            file = 'dmpc_matrices.h'
            
        header = header.format(prefix + file)

        return header


    def includes(self, ftype='src', prefix=None):

        if prefix is None:
            prefix = ''
        else:
            prefix = prefix + '_'

        file = 'dmpc_matrices'

        if ftype == 'src':
            txt = '\n#include "{:}"\n'.format(prefix + file + '.h')
            guard_end = ''
        else:
            def_guard = prefix.upper() + file.upper() + '_H_'
            if prefix is not None: def_guard = def_guard

            def_guard_txt = '#ifndef {:}\n'\
                        '#define {:}\n'
            def_guard_txt = def_guard_txt.format(def_guard, def_guard)   

            include_header = '\n#include "stdint.h"\n'

            txt = '\n' + def_guard_txt + include_header

            guard_end = '\n#endif /* {:} */\n'.format(def_guard)

        return txt, guard_end


    def cnt(self, lim, idx, scaling=1.0, cnt='input', ftype='src', prefix=None):

        if lim is None:
            return ''
        
        if prefix is None:
            prefix = ''
        else:
            prefix = prefix.upper() + '_'

        fill = True
        extern = ''
        if ftype != 'src':
            fill = False
            extern = 'extern '

        cnt_txt = 'DMPC_CONFIG_U'
        comment = '/* Input constraints */\n'
        if cnt != 'input':
            cnt_txt = 'DMPC_CONFIG_XM'
            comment = '/* State constraints */\n'
        
        min_txt = extern + 'float {:}{:}_MIN'.format(prefix, cnt_txt)
        max_txt = extern + 'float {:}{:}_MAX'.format(prefix, cnt_txt)
        lim_idx_txt = extern + 'uint32_t {:}{:}_LIM_IDX'.format(prefix, cnt_txt)

        min_txt = self._export_np_array_to_c(lim[0] / scaling, min_txt, fill=fill) + '\n'
        max_txt = self._export_np_array_to_c(lim[1] / scaling, max_txt, fill=fill) + '\n'
        lim_idx_txt = self._export_np_array_to_c(idx, lim_idx_txt, fill=fill) + '\n'

        txt = '\n' + comment + min_txt + max_txt + lim_idx_txt
        
        return txt


    def output_idx(self, idx, ftype='src', prefix=None):

        if prefix is None:
            prefix = ''
        else:
            prefix = prefix.upper() + '_'

        fill = True
        extern = ''
        if ftype != 'src':
            fill = False
            extern = 'extern '

        comment = '/* Index of ouputs */\n'
        y_idx_txt = extern + 'uint32_t {:}DMPC_CONFIG_Y_IDX'.format(prefix)

        idx_txt = self._export_np_array_to_c(idx, y_idx_txt, fill=fill) + '\n'

        txt = '\n' + comment + idx_txt
        
        return txt


    def Am_Bm_matrices_pred(self, Am, Bm, Bd=None, ftype='src', prefix=None):

        if prefix is None:
            prefix = ''
        else:
            prefix = prefix.upper() + '_'

        fill = True
        nl = '\n'
        extern = ''
        if ftype != 'src':
            fill = False
            extern = 'extern '
            nl = ''

        if Bd is not None:
            B = np.concatenate((Bm, Bd), axis=1)
        else:
            B = Bm
        
        comment = '/*\n'\
                  ' * A and B matrices for prediction.\n'\
                  ' * A corresponds to model matrix Am.\n'\
                  ' * B corresponds to model matrix Bm concatenated with Bd, if Bd exists.\n'\
                  '*/\n'

        A_txt = extern + 'float {:}DMPC_M_A'.format(prefix)
        B_txt = extern + 'float {:}DMPC_M_B'.format(prefix)

        A_txt = self._export_np_array_to_c(Am, A_txt, fill=fill) + '\n'
        B_txt = self._export_np_array_to_c(B, B_txt, fill=fill) + '\n'

        txt = '\n' + comment + A_txt + nl + B_txt
        
        return txt


    def Kx_Ky_gains(self, Kx, Ky, ftype='src', prefix=None):

        if prefix is None:
            prefix = ''
        else:
            prefix = prefix.upper() + '_'

        fill = True
        nl = '\n'
        extern = ''
        if ftype != 'src':
            fill = False
            extern = 'extern '
            nl = ''
        
        comment = '/* Optimal Kx and Ky for unconstrained problems */\n'

        Kx_txt = extern + 'float {:}DMPC_Kx'.format(prefix)
        Ky_txt = extern + 'float {:}DMPC_Ky'.format(prefix)

        Kx_txt = self._export_np_array_to_c(Kx, Kx_txt, fill=fill) + '\n'
        Ky_txt = self._export_np_array_to_c(Ky, Ky_txt, fill=fill) + '\n'

        txt = '\n' + comment + Kx_txt + nl + Ky_txt
        
        return txt
    

    def qp_matrices(self, Ej, M, ftype='src', prefix=None):

        n = Ej.shape[0]
        m = M.shape[0]
        
        if prefix is None:
            prefix = ''
        else:
            prefix = prefix.upper() + '_'

        fill = True
        extern = ''
        nl = '\n'
        if ftype != 'src':
            fill = False
            extern = 'extern '
            nl = ''

        comment = '\n/*\n * Matrices for QP solvers \n'\
                   ' *\n'\
                   ' * The matrices were generated considering the following problem:\n'\
                   ' *\n'\
                   ' * min (1/2) * DU\' * Ej * DU + DU\' * Fj\n'\
                   ' * DU\n'\
                   ' *\n'\
                   ' * s.t. M * DU <= gam\n'\
                   ' *\n'\
                   ' * The (1/2) term in from of DU\' * Ej * DU needs to be considered in the QP\n'\
                   ' * solver selected, or the solution will appear to be inconsistent.\n'\
                   ' * Note that the Fj and gam matrices are usually updated online, while Ej\n'\
                   ' * and M are static.\n'\
                   ' */\n'

        Ej_txt = extern + 'float {:}DMPC_M_Ej'.format(prefix)
        Fj_txt = nl + extern + 'float {:}DMPC_M_Fj'.format(prefix)

        M_txt = nl + extern + 'float {:}DMPC_M_M'.format(prefix)
        gam_txt = nl + extern + 'float {:}DMPC_M_gam'.format(prefix)

        # Generates dummy matrices for Fj and gam, since they are updated
        # at every iteration.
        Fj = np.zeros(n)
        gam = np.zeros(m)
        
        Ej_txt = self._export_np_array_to_c(Ej, Ej_txt, fill=fill) + '\n'
        Fj_txt = self._export_np_array_to_c(Fj, Fj_txt, fill=False) + '\n'

        M_txt = self._export_np_array_to_c(M, M_txt, fill=fill) + '\n'
        gam_txt = self._export_np_array_to_c(gam, gam_txt, fill=False) + '\n'

        txt = comment + Ej_txt + Fj_txt + M_txt + gam_txt

        return txt
    

    def hild_matrices(self, Fj1, Fj2, Fx, Kj1, Hj, DU1, DU2, ftype='src', prefix=None):
        
        if prefix is None:
            prefix = ''
        else:
            prefix = prefix.upper() + '_'

        fill = True
        extern = ''
        nl = '\n'
        if ftype != 'src':
            fill = False
            extern = 'extern '
            nl = ''

        comments = '\n/* Matrices for Hildreth\'s QP procedure */\n'
        
        Fj1_txt = extern + 'float {:}DMPC_M_Fj_1'.format(prefix)
        Fj1_txt = self._export_np_array_to_c(Fj1, Fj1_txt, fill=fill) + '\n'
        
        Fj2_txt = nl + extern + 'float {:}DMPC_M_Fj_2'.format(prefix)
        Fj2_txt = self._export_np_array_to_c(Fj2, Fj2_txt, fill=fill) + '\n'
        
        Fx_txt = nl + extern + 'float {:}DMPC_M_Fx'.format(prefix)
        Fx_txt = self._export_np_array_to_c(Fx, Fx_txt, fill=fill) + '\n'
        
        Kj1_txt = nl + extern + 'float {:}DMPC_M_Kj_1'.format(prefix)
        Kj1_txt = self._export_np_array_to_c(Kj1, Kj1_txt, fill=fill) + '\n'
        
        Hj_txt = nl + extern + 'float {:}DMPC_M_Hj'.format(prefix)
        Hj_txt = self._export_np_array_to_c(Hj, Hj_txt, fill=fill) + '\n'
        
        DU1_txt = nl + extern + 'float {:}DMPC_M_DU_1'.format(prefix)
        DU1_txt = self._export_np_array_to_c(DU1, DU1_txt, fill=fill) + '\n'
        
        DU2_txt = nl + extern + 'float {:}DMPC_M_DU_2'.format(prefix)
        DU2_txt = self._export_np_array_to_c(DU2, DU2_txt, fill=fill) + '\n'

        txt = comments + \
              Fj1_txt + Fj2_txt + Fx_txt +\
              Kj1_txt + Hj_txt + DU1_txt + DU2_txt
        
        return txt


    def defs_header(self, n_xm, n_xa, ny, nu, nd, n_pred, n_ctl, n_cnt, n_lambda, nu_cnt, n_st_cnt, scaling=1.0, prefix=None):

        header = '/**\n'\
         ' * @file {:}\n'\
         ' * @brief Header with definitions to aid the DMPC algorithm.\n'\
         ' *\n'\
         ' * This file is generated automatically and should not be modified.\n'\
         ' *\n'\
         ' */\n'

        if prefix is None:
            prefix = ''
        else:
            prefix = prefix + '_'

        tab_size = len(prefix.upper() + 'DMPC_CONFIG_NLAMBDA')
        tab = '{{:<{:}}}'.format(tab_size + 4)
        
        file = prefix + 'dmpc_defs'
        
        header = header.format(file + '.h')

        def_guard = file.upper() + '_H_'

        def_guard_txt = '\n#ifndef {:}\n'\
                    '#define {:}\n'
        def_guard_txt = def_guard_txt.format(def_guard, def_guard)

        guard_end_txt = '\n#endif /* {:} */\n'.format(def_guard)

        scale_def = (tab + '{:f}f').format(prefix.upper() + 'DMPC_CONFIG_SCALE', scaling)
        scale_txt = '\n/* Scaling factor */\n'\
                     '#define {:}\n'.format(scale_def)

        n_xm_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NXM', n_xm)
        n_xa_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NXA', n_xa)
        n_states_txt = '\n/* Number of model states and augmented states */\n'+\
                       '#define {:}\n'.format(n_xm_def)+\
                       '#define {:}\n'.format(n_xa_def)

        n_pred_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NP', n_pred)
        n_ctl_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NC', n_ctl)
        n_cnt_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NR', n_cnt)
        n_lambda_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NLAMBDA', n_lambda)

        n_hor_txt = '\n/* Prediction, control and constraint horizon */\n'+\
                    '#define {:}\n'.format(n_pred_def)+\
                    '#define {:}\n'.format(n_ctl_def)+\
                    '#define {:}\n'.format(n_cnt_def)+\
                    '#define {:}\n'.format(n_lambda_def)


        n_in_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NU', nu)
        n_out_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NY', ny)
        n_dist_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_ND', nd)
        n_in_out_txt = '\n/* Number of inputs, outputs, and disturbances */\n'+\
                       '#define {:}\n'.format(n_in_def)+\
                       '#define {:}\n'.format(n_out_def)+\
                       '#define {:}\n'.format(n_dist_def)

        n_ctl_def = prefix.upper() + 'DMPC_CONFIG_NC'
        nu_def = prefix.upper() + 'DMPC_CONFIG_NU'
        size_u = tab.format(prefix.upper() + 'DMPC_CONFIG_NC_x_NU') + '({:} * {:})'.format(n_ctl_def, nu_def)
        n_size_u_txt = '\n/* Size of control vector */\n'+\
                       '#define {:}\n'.format(size_u)

        n_input_cnt_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NU_CTR', nu_cnt)
        n_input_cnt_txt = '\n/* Input constraints */\n'+\
                          '#define {:}\n'.format(n_input_cnt_def)

        n_st_cnt_def = (tab + '{:}').format(prefix.upper() + 'DMPC_CONFIG_NXM_CTR', n_st_cnt)
        n_st_cnt_txt = '\n/* State constraints */\n'+\
                          '#define {:}\n'.format(n_st_cnt_def)

        defs_txt = header + def_guard_txt +\
                   scale_txt +\
                   n_states_txt + n_hor_txt + n_in_out_txt +\
                   n_size_u_txt + n_input_cnt_txt + n_st_cnt_txt +\
                   guard_end_txt
        
        return defs_txt
